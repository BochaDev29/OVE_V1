import type { ProjectConfig } from '../../../lib/electrical-rules';
import type { SymbolItem } from '../../../types/planner';

/**
 * Generador autom√°tico de diagrama unifilar
 * 
 * Genera la estructura base del diagrama unifilar a partir de la configuraci√≥n
 * del Wizard Step 3, incluyendo:
 * - Acometida (medidor, t√©rmica general)
 * - Tableros (TP, TS, TSG)
 * - Protecciones (diferenciales, PIAs)
 * - Circuitos terminales
 * - Sistema PAT (bornera, jabalina)
 * 
 * El diagrama generado es 100% editable por el usuario.
 */

interface UnifilarGenerationOptions {
    /** Espaciado vertical entre elementos (px) */
    verticalSpacing?: number;
    /** Espaciado horizontal para jerarqu√≠a (px) */
    horizontalSpacing?: number;
    /** Posici√≥n inicial X */
    startX?: number;
    /** Posici√≥n inicial Y */
    startY?: number;
}

const DEFAULT_OPTIONS: UnifilarGenerationOptions = {
    verticalSpacing: 80,
    horizontalSpacing: 200,
    startX: 100,
    startY: 100
};

let symbolIdCounter = 0;

/**
 * Genera un ID √∫nico para s√≠mbolos
 */
function generateSymbolId(prefix: string = 'unifilar'): string {
    return `${prefix}-${Date.now()}-${symbolIdCounter++}`;
}

/**
 * Crea una l√≠nea de conexi√≥n (pipe) entre dos s√≠mbolos
 */
function createConnectionPipe(from: SymbolItem, to: SymbolItem): any {
    return {
        id: generateSymbolId('pipe'),
        points: [from.x, from.y, to.x, to.y],
        color: '#000000',
        type: 'straight',
        layer: 'layer-0'
    };
}

/**
 * Genera el diagrama unifilar completo desde la configuraci√≥n del proyecto
 */
export function generateUnifilarDiagram(
    config: ProjectConfig,
    options: UnifilarGenerationOptions = {}
): { symbols: SymbolItem[]; pipes: any[] } {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const symbols: SymbolItem[] = [];
    const pipes: any[] = [];

    let currentY = opts.startY!;
    const baseX = opts.startX!;

    // Detectar si es trif√°sico
    const isTrifasico = config.acometida?.phases === 3;

    console.log('üîß Generando diagrama unifilar:', {
        isTrifasico,
        panels: config.panels?.length || 0,
        circuits: config.circuitInventoryForCAD?.length || 0
    });

    // 1. ACOMETIDA (Red ‚Üí Medidor ‚Üí T√©rmica General)
    const acometidaResult = generateAcometida(config, baseX, currentY, isTrifasico);
    symbols.push(...acometidaResult.symbols);
    currentY = acometidaResult.nextY;

    // Conexiones de acometida
    if (acometidaResult.symbols.length >= 2) {
        // L√≠nea: Feed Point ‚Üí Meter
        pipes.push(createConnectionPipe(
            acometidaResult.symbols[0],
            acometidaResult.symbols[1]
        ));

        // L√≠nea: Meter ‚Üí Main Breaker
        if (acometidaResult.symbols.length >= 3) {
            pipes.push(createConnectionPipe(
                acometidaResult.symbols[1],
                acometidaResult.symbols[2]
            ));
        }
    }

    // 2. TABLEROS (TP, TS, TSG)
    if (config.panels && config.panels.length > 0) {
        currentY += opts.verticalSpacing!;

        config.panels.forEach((panel, index) => {
            const panelX = baseX + (index * opts.horizontalSpacing!);
            const panelResult = generatePanel(panel, config, panelX, currentY, isTrifasico);
            symbols.push(...panelResult.symbols);

            // Conexi√≥n: Main Breaker ‚Üí Panel Label
            if (acometidaResult.symbols.length > 0 && panelResult.symbols.length > 0) {
                pipes.push(createConnectionPipe(
                    acometidaResult.symbols[acometidaResult.symbols.length - 1],
                    panelResult.symbols[0]
                ));
            }

            // Conexiones internas del panel
            pipes.push(...panelResult.pipes);
        });
    }

    console.log(`‚úÖ Diagrama generado: ${symbols.length} s√≠mbolos, ${pipes.length} conexiones`);

    return { symbols, pipes };
}

/**
 * Genera s√≠mbolos de acometida (red ‚Üí medidor ‚Üí t√©rmica general)
 */
function generateAcometida(
    config: ProjectConfig,
    x: number,
    y: number,
    isTrifasico: boolean
): { symbols: SymbolItem[]; nextY: number } {
    const symbols: SymbolItem[] = [];
    let currentY = y;

    // 1. Punto de alimentaci√≥n (red)
    symbols.push({
        id: generateSymbolId('feed'),
        type: 'feed_point',
        x,
        y: currentY,
        rotation: 0,
        label: isTrifasico ? '3x380V + N + PE' : '220V + PE',
        fontSize: 12,
        layer: 'layer-0',
        autoGenerated: true
    });

    currentY += 60;

    // 2. Medidor
    symbols.push({
        id: generateSymbolId('meter'),
        type: 'meter',
        x,
        y: currentY,
        rotation: 0,
        label: 'Medidor',
        fontSize: 12,
        layer: 'layer-0',
        autoGenerated: true
    });

    currentY += 60;

    // 3. T√©rmica general (main breaker)
    const mainBreakerLabel = isTrifasico
        ? `4x${config.acometida?.mainBreaker?.rating || 63}A`
        : `2x${config.acometida?.mainBreaker?.rating || 40}A`;

    symbols.push({
        id: generateSymbolId('main-breaker'),
        type: 'main_breaker',
        x,
        y: currentY,
        rotation: 0,
        label: mainBreakerLabel,
        fontSize: 12,
        layer: 'layer-0',
        autoGenerated: true
    });

    currentY += 80;

    return { symbols, nextY: currentY };
}

/**
 * Genera s√≠mbolos de un tablero (rect√°ngulo + protecciones + circuitos)
 */
function generatePanel(
    panel: any,
    config: ProjectConfig,
    x: number,
    y: number,
    isTrifasico: boolean
): { symbols: SymbolItem[]; pipes: any[]; nextY: number } {
    const symbols: SymbolItem[] = [];
    const pipes: any[] = [];
    let currentY = y;

    // 1. Etiqueta del tablero
    symbols.push({
        id: generateSymbolId('panel-label'),
        type: 'text',
        x,
        y: currentY,
        rotation: 0,
        label: `${panel.name} (${panel.type})`,
        fontSize: 14,
        color: '#1e40af',
        layer: 'layer-0',
        autoGenerated: true
    });

    currentY += 40;

    // 2. Diferencial (si existe)
    const diffHeader = panel.protections?.headers?.find((h: any) => h.type === 'ID');
    if (diffHeader) {
        const diffLabel = generateDiffLabel(diffHeader, isTrifasico);
        symbols.push({
            id: generateSymbolId('diff'),
            type: 'diff_switch',
            x,
            y: currentY,
            rotation: 0,
            label: diffLabel,
            fontSize: 11,
            layer: 'layer-0',
            autoGenerated: true
        });

        // Conexi√≥n: Panel Label ‚Üí Diferencial
        pipes.push(createConnectionPipe(symbols[0], symbols[1]));

        currentY += 60;
    }

    // 3. Circuitos del tablero
    const panelCircuits = config.circuitInventoryForCAD?.filter(
        c => c.panelId === panel.id
    ) || [];

    const diffSymbol = symbols.find(s => s.type === 'diff_switch');
    let previousPIA: SymbolItem | null = null;

    panelCircuits.forEach((circuit, _index) => {
        // PIA del circuito
        const piaLabel = generatePIALabel(circuit, isTrifasico);
        const piaType = (isTrifasico && circuit.cable?.conductors === 4 ? 'tm_4p' : 'tm_2p') as 'tm_2p' | 'tm_4p';

        const piaSymbol: SymbolItem = {
            id: generateSymbolId(`pia-${circuit.id}`),
            type: piaType,
            x,
            y: currentY,
            rotation: 0,
            label: `${circuit.designation} - ${piaLabel}`,
            fontSize: 10,
            layer: 'layer-0',
            autoGenerated: true,
            circuitId: circuit.id
        };

        symbols.push(piaSymbol);

        // Conexi√≥n: Diferencial ‚Üí Primera PIA o PIA anterior ‚Üí PIA actual
        if (diffSymbol && !previousPIA) {
            pipes.push(createConnectionPipe(diffSymbol, piaSymbol));
        } else if (previousPIA) {
            pipes.push(createConnectionPipe(previousPIA, piaSymbol));
        }

        previousPIA = piaSymbol;
        currentY += 50;
    });

    return { symbols, pipes, nextY: currentY };
}

/**
 * Genera etiqueta t√©cnica para una PIA
 */
function generatePIALabel(circuit: any, isTrifasico: boolean): string {
    const poles = circuit.cable?.conductors === 4 ? 4 : 2;
    const rating = circuit.protection?.rating || 10;
    const curve = circuit.protection?.curve || 'C';
    const icu = circuit.protection?.breakingCapacity || 3;

    return `${poles}x${rating}A ${curve} ${icu}kA`;
}

/**
 * Genera etiqueta t√©cnica para un diferencial
 */
function generateDiffLabel(diffHeader: any, isTrifasico: boolean): string {
    const poles = isTrifasico ? 4 : 2;
    const rating = diffHeader.rating || 25;
    const sensitivity = diffHeader.sensitivity || 30;

    return `${poles}x${rating}A ${sensitivity}mA`;
}

/**
 * Genera etiqueta t√©cnica para un cable
 */
function generateCableLabel(circuit: any): string {
    const conductors = circuit.cable?.conductors || 2;
    const section = circuit.cable?.section || 1.5;
    const type = circuit.cable?.type || 'IRAM NM 247-3';

    return `${conductors}x${section}mm¬≤ + PE "${type}"`;
}
